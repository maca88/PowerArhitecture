using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using FluentValidation.Validators;
using NHibernate;
using NHibernate.Metadata;
using PowerArhitecture.Breeze.Metadata;
using PowerArhitecture.Breeze.Specification;
using PowerArhitecture.Domain;
using PowerArhitecture.Validation;
using PowerArhitecture.Validation.Specifications;
using FluentValidation.Internal;

namespace PowerArhitecture.Breeze
{
    public class BreezeMetadataConfigurator
    {
        private readonly IValidatorFactoryExtended _validatorFactory;

        public BreezeMetadataConfigurator(IValidatorFactoryExtended validatorFactory)
        {
            _validatorFactory = validatorFactory;
        }

        private void SetFluentValidators(DataProperty dataProp)
        {
            var nullableProps = new HashSet<string> {"LastModifiedById", "CreatedById", "LastModifiedDate", "CreatedDate"};
            var toReplace = new HashSet<string> {"required", "maxLength"};
            foreach (var validator in dataProp.Validators.Where(o => toReplace.Contains(o.Name)).ToList())
            {
                dataProp.Validators.Remove(validator);
                Validator newValidator = null;
                var name = validator.Name;
                if (name == "required" && nullableProps.Contains(dataProp.NameOnServer))
                {
                    dataProp.IsNullable = true;
                    continue;
                }
                    
                switch (name)
                {
                    case "required":
                        newValidator = new Validator {Name = "fvNotEmpty"};
                        var defVal = dataProp.PropertyInfo != null 
                            ? dataProp.PropertyInfo.PropertyType.GetDefaultValue()
                            : null;
                        newValidator.MergeLeft(FluentValidators.GetParamaters(new NotEmptyValidator(defVal)));
                        break;
                    case "maxLength":
                        newValidator = new Validator {Name = "fvLength"};
                        newValidator.MergeLeft(FluentValidators.GetParamaters(new LengthValidator(0, dataProp.MaxLength)));
                        break;
                }
                dataProp.Validators.Add(newValidator);
            }
        }

        public void Configure(IDictionary<string, object> metadata, ISessionFactory sessionFactory)
        {
            if (metadata.ContainsKey("processed")) return;

            var metadataSchema = new MetadataSchema(metadata);
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            var clientModelTypes = assemblies
                .Where(a => a.GetTypes().Any(t => typeof(IClientModel).IsAssignableFrom(t)))
                .SelectMany(a => a.GetTypes().Where(t => typeof(IClientModel).IsAssignableFrom(t)))
                .ToList();
            var serverModelTypes = assemblies
                .Where(a => a.GetTypes().Any(t => typeof(IEntity).IsAssignableFrom(t)))
                .SelectMany(a => a.GetTypes().Where(t => typeof(IEntity).IsAssignableFrom(t)))
                .ToList();
            var allTypesDict = serverModelTypes.Union(clientModelTypes).ToDictionary(o => o.FullName);

            //Add client models to metadata
            foreach (var clientModelType in clientModelTypes)
            {
                //Create new structure as entityType with a fake id property
                var structType = new EntityType(clientModelType)
                {
                    AutoGeneratedKeyType = AutoGeneratedKeyType.KeyGenerator
                };

                foreach (var prop in clientModelType.GetProperties())
                {
                    //add a nav property
                    if (typeof(IEntity).IsAssignableFrom(prop.PropertyType))
                    {
                        var syntheticPropName = prop.Name + "Id";
                        var classMetadata = sessionFactory.GetClassMetadata(prop.PropertyType);
                        var property = new DataProperty
                        {
                            DataType = BreezeTypeHelper.GetDataType(classMetadata.IdentifierType.ReturnedClass),
                            NameOnServer = syntheticPropName,
                            IsNullable = true
                        };
                        structType.DataProperties.Add(property);
                        var navProp = new NavigationProperty
                        {
                            IsScalar = true,
                            EntityTypeName = string.Format("{0}:#{1}", prop.PropertyType.Name, prop.PropertyType.Namespace),
                            NameOnServer = prop.Name,
                            AssociationName = string.Format("AN_{0}_{1}_{2}", prop.PropertyType.Name, prop.Name, syntheticPropName),
                            ForeignKeyNamesOnServer = new List<string> { syntheticPropName }
                        };
                        structType.NavigationProperties.Add(navProp);
                        metadataSchema.FkMap[string.Format("{0}.{1}", clientModelType.FullName, prop.Name)] = syntheticPropName;
                    }
                    else
                    {
                        var dataProp = new DataProperty(prop)
                        {
                            IsPartOfKey = prop.Name == "Id"
                        };

                        var defAttr = prop.GetCustomAttribute<DefaultValueAttribute>();
                        if (defAttr != null)
                        {
                            dataProp.DefaultValue = defAttr.Value;
                        }

                        //if (prop.PropertyType == typeof (string))
                        //    dataProp.DefaultValue = ""; //TODO: configurable -added because od ui-select
                        structType.DataProperties.Add(dataProp);
                    }
                }
                structType["isUnmapped"] = true;
                metadataSchema.StructuralTypes.Add(structType);
            }

            foreach (var structType in metadataSchema.StructuralTypes.Where(o => allTypesDict.ContainsKey(o.TypeFullName)))
            {
                var type = allTypesDict[structType.TypeFullName];
                var modelValidator = _validatorFactory.GetValidator(type);
                var membersRules = modelValidator.OfType<PropertyRule>()
                    .Where(o => o.PropertyName != null)
                    .ToLookup(o => o.PropertyName, o => o);

                foreach (var dataProp in structType.DataProperties)
                {
                    if (!membersRules.Contains(dataProp.NameOnServer))
                    {
                        SetFluentValidators(dataProp);
                        continue;
                    }
                    var propRules = membersRules[dataProp.NameOnServer];
                    foreach (var propRule in propRules.Where(o => o.RuleSet == null || ValidationRuleSet.AttributeInsertUpdateDefault.Contains(o.RuleSet)))
                    {
                        dataProp.Validators.Remove("maxLength");
                        dataProp.Validators.Remove("required");
                        var currVal = propRule.CurrentValidator;
                        var name = FluentValidators.GetName(currVal);
                        if (name == null) continue; //add only registered validators
                        var validator = new Validator { Name = name };
                        validator.MergeLeft(FluentValidators.GetParamaters(currVal));
                        dataProp.Validators.Add(validator);
                    }
                }
                //This is not the right approach as we then have to load all navigation properties in order to save the entity
                //var entityType = structType as EntityType;
                //if (entityType == null) continue;
                //foreach (var navProp in entityType.NavigationProperties)
                //{
                //    var source = navProp.ForeignKeyNamesOnServer ?? new List<string>();
                //    var fkPropName = source.FirstOrDefault();
                //    if (fkPropName == null) 
                //        continue; //null for inverse fks

                //    var prop = entityType.DataProperties.First(o => (o.NameOnServer == fkPropName));
                //    if (prop.IsNullable) continue;
                //    var notNullVal = new Validator
                //    {
                //        Name = "fvNotNull"
                //    };
                //    notNullVal.MergeLeft(FluentValidators.GetParamaters(new NotNullValidator()));
                //    navProp.Validators.Add(notNullVal);
                //}
            }

            metadata["processed"] = true;
        }
    }
}