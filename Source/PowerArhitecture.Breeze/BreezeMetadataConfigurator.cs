using System;
using System.Collections.Generic;
using System.Linq;
using PowerArhitecture.Breeze.Metadata;
using PowerArhitecture.Breeze.Specification;
using PowerArhitecture.Domain;
using PowerArhitecture.Validation;
using PowerArhitecture.Validation.Specifications;
using FluentValidation.Internal;

namespace PowerArhitecture.Breeze
{
    public class BreezeMetadataConfigurator
    {
        private readonly IValidatorFactoryExtended _validatorFactory;

        public BreezeMetadataConfigurator(IValidatorFactoryExtended validatorFactory)
        {
            _validatorFactory = validatorFactory;
        }

        public void Configure(IDictionary<string, object> metadata)
        {
            if (metadata.ContainsKey("processed")) return;

            var metadataSchema = new MetadataSchema(metadata);
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            var clientModelTypes = assemblies
                .Where(a => a.GetTypes().Any(t => typeof(IClientModel).IsAssignableFrom(t)))
                .SelectMany(a => a.GetTypes().Where(t => typeof(IClientModel).IsAssignableFrom(t)))
                .ToList();
            var serverModelTypes = assemblies
                .Where(a => a.GetTypes().Any(t => typeof(IEntity).IsAssignableFrom(t)))
                .SelectMany(a => a.GetTypes().Where(t => typeof(IEntity).IsAssignableFrom(t)))
                .ToList();
            var allTypesDict = serverModelTypes.Union(clientModelTypes).ToDictionary(o => o.FullName);

            //Add client models to metadata
            foreach (var clientModelType in clientModelTypes)
            {
                //Create new structure as entityType with a fake id property
                var structType = new EntityType(clientModelType)
                {
                    AutoGeneratedKeyType = AutoGeneratedKeyType.KeyGenerator
                };
                structType.DataProperties.First(o => o.NameOnServer == "Id").IsPartOfKey = true;
                structType["isUnmapped"] = true;
                metadataSchema.StructuralTypes.Add(structType);
            }

            foreach (var structType in metadataSchema.StructuralTypes.Where(o => allTypesDict.ContainsKey(o.TypeFullName)))
            {
                var type = allTypesDict[structType.TypeFullName];
                var modelValidator = _validatorFactory.GetValidator(type);
                var membersRules = modelValidator.OfType<PropertyRule>()
                    .Where(o => o.PropertyName != null)
                    .ToLookup(o => o.PropertyName, o => o);

                foreach (var dataProp in structType.DataProperties)
                {
                    if (!membersRules.Contains(dataProp.NameOnServer)) continue;
                    var propRules = membersRules[dataProp.NameOnServer];
                    foreach (var propRule in propRules.Where(o => o.RuleSet == null || ValidationRuleSet.AttributeInsertUpdateDefault.Contains(o.RuleSet)))
                    {
                        dataProp.Validators.Remove("maxLength");
                        dataProp.Validators.Remove("required");
                        var currVal = propRule.CurrentValidator;
                        var name = FluentValidators.GetName(currVal);
                        if (name == null) continue; //add only registered validators
                        var validator = new Validator { Name = name };
                        validator.MergeLeft(FluentValidators.GetParamaters(currVal));
                        dataProp.Validators.Add(validator);
                    }
                }
            }

            metadata["processed"] = true;
        }
    }
}